using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace EldritchArcana.Helper
{
    public static class Util
    {
        #region General


        public static IEnumerable<T> GetEnumValues<T>()
        {
            return Enum.GetValues(typeof(T)).Cast<T>();
        }
        public static string[] RemoveDuplicates(string[] s)
        {
            HashSet<string> set = new HashSet<string>(s);
            string[] result = new string[set.Count];
            set.CopyTo(result);
            return result;
        }

        public static int SqlBinaryChecksum(string text)
        {
            return Circular_shift(text, CheckSumMode.CHECKSUM_BINARY_SQL);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static int Circular_shift(string input, CheckSumMode checkSumMode)
        {
            short shiftAmmount = (short)checkSumMode;
            uint accumulator = 0;
            foreach (var item in input)
            {
                var leftRotate4bit = (accumulator << shiftAmmount) | (accumulator >> -shiftAmmount);
                accumulator = leftRotate4bit ^ item;
            }
            return (int)accumulator;
        }
        public enum CheckSumMode
        {
            CHECKSUM_BINARY_SQL = 4,
            CHECKSUM_LSHIFT9 = 9,
            CHECKSUM_DOZEN_LSHIFT = 12,
            CHECKSUM_LSHIFT18 = 18,
            CHECKSUM_RSHIFT4 = -4,
            CHECKSUM_RSHIFT9 = -9,
            CHECKSUM_DOZEN_RSHIFT = -12,
            CHECKSUM_RSHIFT18 = -18,
        }

        /// <summary>
        /// 
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="obj">object to be checksumd</param>
        /// <param name="checkSumMode">The Default Is CheckSum Binary SQL to match the checksum generated By Sql Databases. 
        /// Although by increasing the shift ammount the data loss is reduced. BINARY_SQL reccomended Up untill 255 chars. to maintain without data loss. 
        /// higher shifts or lower shifts Could increase the ammount of data maintained shifting by <9> up to 2042  <12> 2242  shifting by <18> you have virtualy no data loss</param>
        /// <returns></returns>
        public static int GetChecksumInt<T>(this T obj, CheckSumMode checkSumMode = CheckSumMode.CHECKSUM_BINARY_SQL)
        {
            return Circular_shift(ObjectToString(obj, false), checkSumMode);
        }
        public static int GetChecksumInt<T>(this IEnumerable<T> obj, CheckSumMode checkSumMode = CheckSumMode.CHECKSUM_BINARY_SQL)
        {
            return Circular_shift((ObjectToString(obj, false)), checkSumMode);
        }
        public static string ObjectToString<T>(this T obj, bool useSeparators = true)
        {
            return ObjectToString(new List<T>() { obj }.AsEnumerable(), useSeparators);
        }
        public static string ObjectToString<T>(this List<T> obj, bool useSeparators = true)
        {
            return ObjectToString((IEnumerable<T>)obj, useSeparators);
        }
        public static string ObjectToString<T>(this IEnumerable<T> obj, string mainSeparator = ";", string subSeparator = ",")
        {
            var fields = typeof(T).GetProperties();
            return String.Join(mainSeparator, obj.Select(x =>
                                String.Join(subSeparator, fields.Select(f => f.GetValue(x)))
                            ));
        }
        public static DateTime TruncDate(this DateTime dateTime, TimeSpan timeSpan)
        {
            if (timeSpan == TimeSpan.Zero) return dateTime; // Or could throw an ArgumentException
            if (dateTime == DateTime.MinValue || dateTime == DateTime.MaxValue) return dateTime; // do not modify "guard" values
            return dateTime.AddTicks(-(dateTime.Ticks % timeSpan.Ticks));
        }
        public static DateTime TruncDate(DateTime dateTime)
        {
            return DateTime.ParseExact(dateTime.ToString("yyyy-MM-dd HH:mm:ss"), "yyyy-MM-dd HH:mm:ss", null);
        }
        internal static bool Compare<T>(T obj1, T obj2)
        {
#if !DEBUG
            return ObjectToString(obj1, false) == ObjectToString(obj2, false);
#else
            var string1 = ObjectToString(obj1);
            var string2 = ObjectToString(obj2);
            return string1 == string2;
#endif
        }
        private static string MakeValidFileName(string name)
        {
            string invalidChars = System.Text.RegularExpressions.Regex.Escape(new string(System.IO.Path.GetInvalidFileNameChars()));
            string invalidRegStr = string.Format(@"([{0}]*\.+$)|([{0}]+)", invalidChars);
            return System.Text.RegularExpressions.Regex.Replace(name, invalidRegStr, "_");
        }

        #endregion General
        #region Json
        internal static bool CompareJson<T>(T obj1, T obj2)
        {
#if !DEBUG
            return ToJsonString(obj1) == ToJsonString(obj2);
#else
            var string1 = ToJsonString(obj1);
            var string2 = ToJsonString(obj2);
            return string1 == string2;
#endif
        }
        public static int GetJsonChecksum<T>(T obj, CheckSumMode checkSumMode = CheckSumMode.CHECKSUM_DOZEN_LSHIFT)
        {
            return Circular_shift((ToJsonString(obj)), checkSumMode);
        }
        public static string ToJsonString<T>(T obj)//, bool fastUnsafe=false)
        {
            //return Newtonsoft.Json.JsonConvert.SerializeObject(obj);
            return fastJSON.JSON.ToJSON(obj);
        }


        /// <summary>
        /// this function can be used to write to a json file easily the implementation can differ between files
        /// </summary>
        /// <typeparam name="T">Generic type parameter</typeparam>
        /// <param name="data">Data to be written to file</param>
        /// <param name="fileName">filename (without extension)</param>
        internal static void WriteToJsonFile<T>(T data, string fileName = null)
        {
            using (System.IO.StreamWriter file = System.IO.File.CreateText($"{fileName ?? typeof(T).ToString()}.Json"))
            {
                file.Write(ToJsonString(data));
            }
        }
        internal static void WriteToFile(Byte[] data, string fileName = null)
        {
            System.IO.File.WriteAllBytes($"{fileName ?? GenerateFakeName() + ".txt"}", data);
        }

        internal static T ReadFromJsonFile<T>(string fileName = null)
        {
            fileName = $"{fileName ?? typeof(T).ToString()}.Json";
            using (System.IO.StreamReader file = System.IO.File.OpenText(fileName))
            {
                return fastJSON.JSON.ToObject<T>(file.ReadToEnd());
            }
        }

        public static float InvSqrt(float x, bool newtonCorrection = false)
        {
            float xhalf = 0.5f * x;
            int i = BitConverter.ToInt32(BitConverter.GetBytes(x), 0);
            if (newtonCorrection)
                i = 0x5f3759df - (i >> 1);//0x5f3759df == most accurare with one newton correction
            else
                i = 0x5f375a86 - (i >> 1);//0x5f375a86 == most accurate without newton correction
            x = BitConverter.ToSingle(BitConverter.GetBytes(i), 0);
            if (newtonCorrection)
                x = x * (1.5f - xhalf * x * x); // newton correction line
            return x;
        }
        #endregion
        #region FakeTestDataGeneration
        static Random random;
        private static Random rnd { get => random ?? (random = new Random()); }
        public static int Randint(int min = 0, int max = 100)
        {
            return rnd.Next(min, max);
        }
        public static string GenerateFakeName(int len = -1)
        {
            string[] consonants = { "b", "b", "b", "b", "b", "b", "c", "c", "c", "c", "c", "c", "d", "d", "d", "d", "d", "d", "f", "f", "f", "g", "g", "g", "g", "h", "h", "h", "j", "j", "j", "j", "j", "j", "k", "k", "k", "k", "l", "l", "l", "l", "m", "m", "m", "m", "m", "m", "m", "m", "n", "n", "n", "p", "p", "p", "p", "qu", "r", "r", "r", "r", "r", "s", "s", "s", "s", "s", "s", "s", "s", "s", "s", "sh", "zh", "ng", "t", "t", "t", "t", "t", "v", "v", "w", "x", "z" };
            string[] vowels = { "a", "a", "a", "a", "a", "a", "a", "e", "e", "e", "i", "i", "o", "o", "u", "ae", "y" };
            string Name = string.Empty;
            if (len < 0)
                len = Util.rnd.Next(2, 4) + Util.rnd.Next(2, 4);
            if (rnd.Next(0, 3) == 1)
                Name += consonants[rnd.Next(consonants.Length)];
            Name += vowels[rnd.Next(vowels.Length)];
            Name = Name.First().ToString().ToUpper() + Name.Substring(1);
            int b = 1;
            while (b < len)
            {
                Name += consonants[rnd.Next(consonants.Length)];
                Name += vowels[rnd.Next(vowels.Length)];
                b += 2;
            }
            return Name.Substring(0, len);
        }


        #endregion FakeTestDataGeneration

    }
}
